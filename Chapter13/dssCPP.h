/*
 * dssCPP.h
 *
 *  Created on: 22 Mar 2022
 *      Author: julio
 */
#include <iostream>

#ifndef DSSCPP_H_
#define DSSCPP_H_
#include <fstream>

#define RR 2
#define CC 11

typedef std::vector<std::vector< double > > matrix_type;
typedef std::vector<std::vector< std::vector< double >>> matrix3D_type;
typedef std::vector< double > array_type;
typedef std::vector< double > state_type;

array_type dss00(double xl, double xu, int n, array_type u)
{
	//Compute the spatial increment
	double dx=(xu-xl)/(n-1);
	double rfdx=1.0/dx;
	array_type ux(n);

	ux[0]=rfdx*(u[1] - u[0])/2.0;

	for (int i=0; i<=n-1; i++)
		ux[i]=rfdx*(u[i+1] - u[i-1])/2.0;

	//ux[n-1]=rfdx*(u[n-2] - u[n-1])/2.0;

	return ux;
}

array_type dss02(double xl, double xu, int n, array_type u)
{
	//Compute the spatial increment
	double dx=(xu-xl)/(n-1);
	double r2fdx=1.0/(2.0*dx);
	array_type ux(n);

	ux[0]=r2fdx*(-3.*u[0] + 4.*u[1] - 1.*u[2]);

	for (int i=1; i<n-1; i++)
		ux[i]=r2fdx*(-u[i-1]  + u[i+1]);

	ux[n-1]=r2fdx*(1. *u[n-3] -4.*u[n-2] +3.*u[n-1]);

	return ux;
}

array_type dss04(double xl, double xu, int n, array_type u) {

	//Compute the spatial increment
	double dx=(xu-xl)/(n-1);
	double r4fdx=1.0/(12.0*dx);
	array_type ux(n);

	   ux[0]  = r4fdx*(-25.*u[0] + 48.*u[1] - 36.*u[2] + 16.*u[3] -3.*u[4]);
	   ux[1]  = r4fdx*( -3.*u[0] - 10.*u[1] + 18.*u[2]  - 6.*u[3] +1.*u[4]);

	   for (int i=2; i<n-2; i++){
	     ux[i]= r4fdx*(1.*u[i-2]  - 8.*u[i-1]  + 0.*u[  i]  +8.*u[i+1]  -1.*u[i+2]);
	   }

	   ux[n-2] = r4fdx*(-1.*u[n-5]  + 6.*u[n-4] - 18.*u[n-3] +10.*u[n-2]  +3.*u[n-1]);
	   ux[n-1] = r4fdx*( 3.*u[n-5] - 16.*u[n-4] + 36.*u[n-3] -48.*u[n-2] +25.*u[n-1]);

	   return ux;
}

array_type dss06(double xl, double xu, int n, array_type u) {

//  Compute the spatial increment
    double dx =(xu-xl)/(n-1);
    double r6fdx=1./(720.*dx);
	array_type ux(n);

//
//  Equation [1]system_of_equation_v6
   ux[0]=r6fdx*
     ( -1764.*u[  0]  +4320.*u[  1]  -5400.*u[  2]  +4800.*u[  3]
       -2700.*u[  4]   +864.*u[  5]   -120.*u[  6]);
//
//  Equation [2]
   ux[1]=r6fdx*
     (  -120.*u[  0]   -924.*u[  1]  +1800.*u[  2]  -1200.*u[  3]
        +600.*u[  4]   -180.*u[  5]    +24.*u[  6]);
//
//  Equation [3]
   ux[2]=r6fdx*
     (   +24.*u[  0]   -288.*u[  1]   -420.*u[  2]   +960.*u[  3]
        -360.*u[  4]    +96.*u[  5]    -12.*u[  6]);
//
//  Equation [4]
   for (int i=3; i<n-3; i++)
     ux[i]=r6fdx*
     (  -12.*u[i-3]   +108.*u[i-2]   -540.*u[i-1]     +0.*u[  i]
        +540.*u[i+1]   -108.*u[i+2]    +12.*u[i+3]);

//
//  Equation [5]
   ux[n-3]=r6fdx*
     (   +12.*u[n-7]    -96.*u[n-6]   +360.*u[n-5]   -960.*u[n-4]
        +420.*u[n-3]   +288.*u[n-2]    -24.*u[n-1]);
//
//  Equation [6]
   ux[n-2]=r6fdx*
     (   -24.*u[n-7]   +180.*u[n-6]   -600.*u[n-5]  +1200.*u[n-4]
       -1800.*u[n-3]   +924.*u[n-2]   +120.*u[n-1]);
//
//  Equation [7]
   ux[n-1]=r6fdx*
     ( +120.*u[n-7]   -864.*u[n-6]  +2700.*u[n-5]  -4800.*u[n-4]
       +5400.*u[n-3]  -4320.*u[n-2]  +1764.*u[n-1]);

   return ux;

}


array_type dss08(double xl, double xu, int n, array_type u) {
	//  Compute the spatial increment
	double dx=(xu-xl) /(n-1) ;
	double r8fdx=1./(40320.*dx) ;
	array_type ux(n);

	//
	//  Grid point 1
	ux[ 0] =r8fdx*
	     (-109584.     *u[ 0]
	      +322560.     *u[ 1]
	      -564480.     *u[ 2]
	      +752640.     *u[ 3]
	      -705600.     *u[ 4]
	      +451584.     *u[ 5]
	      -188160.     *u[ 6]
	      +46080.      *u[ 7]
	      -5040.       *u[ 8] ) ;
	//
	//  Grid point 2
	ux[ 1] =r8fdx*
	     (-5040.       *u[ 0]
	      -64224.      *u[ 1]
	      +141120.     *u[ 2]
	      -141120.     *u[ 3]
	      +117600.     *u[ 4]
	      -70560.      *u[ 5]
	      +28224.      *u[ 6]
	      -6720.       *u[ 7]
	      +720.        *u[ 8] ) ;
	//
	//  Grid point 3
	ux[ 2] =r8fdx*
	     (+720.        *u[ 0]
	      -11520.      *u[ 1]
	      -38304.      *u[ 2]
	      +80640.      *u[ 3]
	      -50400.      *u[ 4]
	      +26880.      *u[ 5]
	      -10080.      *u[ 6]
	      +2304.       *u[ 7]
	      -240.        *u[ 8] );
	//
	//  Grid point 4
	ux[ 3] =r8fdx*
	     (-240.        *u[ 0]
	      +2880.       *u[ 1]
	      -20160.      *u[ 2]
	      -18144.      *u[ 3]
	      +50400.      *u[ 4]
	      -20160.      *u[ 5]
	      +6720.       *u[ 6]
	      -1440.       *u[ 7]
	      +144.        *u[ 8] ) ;
	//
	//  Grid point i
	for (int i=4; i< n-4; i++)
		ux[ i] =r8fdx*
	     (+144.        *u[i-4]
	      -1536.       *u[i-3]
	      +8064.       *u[i-2]
	      -32256.      *u[i-1]
	      +0.          *u[i  ]
	      +32256.      *u[i+1]
	      -8064.       *u[i+2]
	      +1536.       *u[i+3]
	      -144.        *u[i+4]) ;
	//
	//  Grid point n-3
	ux[n-4] =r8fdx*
	     (-144.        *u[n-9]
	      +1440.       *u[n-8]
	      -6720.       *u[n-7]
	      +20160.      *u[n-6]
	      -50400.      *u[n-5]
	      +18144.      *u[n-4]
	      +20160.      *u[n-3]
	      -2880.       *u[n-2]
	      +240.        *u[n-1]) ;
	//
	//  Grid point n-2
	ux[n-3] =r8fdx*
	     (+240.        *u[n-9]
	      -2304.       *u[n-8]
	      +10080.      *u[n-7]
	      -26880.      *u[n-6]
	      +50400.      *u[n-5]
	      -80640.      *u[n-4]
	      +38304.      *u[n-3]
	      +11520.      *u[n-2]
	      -720.        *u[n-1] );
	//
	//  Grid point n-1
	ux[n-2] =r8fdx*
	     (-720.        *u[n-9]
	      +6720.       *u[n-8]
	      -28224.      *u[n-7]
	      +70560.      *u[n-6]
	      -117600.     *u[n-5]
	      +141120.     *u[n-4]
	      -141120.     *u[n-3]
	      +64224.      *u[n-2]
	      +5040.       *u[n-1] ) ;
	//
	//  Grid point n
	ux[n-1] =r8fdx*
	     (+5040.       *u[n-9]
	      -46080.      *u[n-8]
	      +188160.     *u[n-7]
	      -451584.     *u[n-6]
	      +705600.     *u[n-5]
	      -752640.     *u[n-4]
	      +564480.     *u[n-3]
	      -322560.     *u[n-2]
	      +109584.     *u[n-1] ) ;

	return ux;
}

array_type dss10(double xl, double xu, int n, array_type u) {
	// Compute the spatial increment
	double  dx=(xu-xl)/(n-1);
	double r10fdx=1./(3628800.*dx);
	array_type ux(n+1);

	//  Grid point 1
	ux[ 0]=r10fdx*
	     (-10628640.    *u[ 0]
	      +36288000.    *u[ 1]
	      -81648000.    *u[ 2]
	      +145152000.   *u[ 3]
	      -190512000.   *u[ 4]
	      +182891520.   *u[ 5]
	      -127008000.   *u[ 6]
	      +62208000.    *u[ 7]
	      -20412000.    *u[ 8]
	      +4032000.     *u[ 9]
	      -362880.      *u[10]);
	  //Grid point 2
	ux[ 1]=r10fdx*
	     (-362880.      *u[ 0]
	      -6636960.     *u[ 1]
	      +16329600.    *u[ 2]
	      -21772800.    *u[ 3]
	      +25401600.    *u[ 4]
	      -22861440.    *u[ 5]
	      +15240960.    *u[ 6]
	      -7257600.     *u[ 7]
	      +2332800.     *u[ 8]
	      -453600.      *u[ 9]
	      +40320.       *u[10]);
	//Grid point 3
	ux[  2]=r10fdx*
	     (+40320.       *u[ 0]
	      -806400.      *u[ 1]
	      -4419360.     *u[ 2]
	      +9676800.     *u[ 3]
	      -8467200.     *u[ 4]
	      +6773760.     *u[ 5]
	      -4233600.     *u[ 6]
	      +1935360.     *u[ 7]
	      -604800.      *u[ 8]
	      +115200.      *u[ 9]
	      -10080.       *u[10]);
	//Grid point 4
	ux[ 3]=r10fdx*
	     (-10080.       *u[ 0]
	      +151200.      *u[ 1]
	      -1360800.     *u[ 2]
	      -2756160.     *u[ 3]
	      +6350400.     *u[ 4]
	      -3810240.     *u[ 5]
	      +2116800.     *u[ 6]
	      -907200.      *u[ 7]
	      +272160.      *u[ 8]
	      -50400.       *u[ 9]
	      +4320.        *u[10]);
	//Grid point 5
	ux[ 4]=r10fdx*
	     (+4320.        *u[ 0]
	      -57600.       *u[ 1]
	      +388800.      *u[ 2]
	      -2073600.     *u[ 3]
	      -1330560.     *u[ 4]
	      +4354560.     *u[ 5]
	      -1814400.     *u[ 6]
	      +691200.      *u[ 7]
	      -194400.      *u[ 8]
	      +34560.       *u[ 9]
	      -2880.        *u[10]);
	//Grid point i, i ne 1 to 5, n-4 to n
	for (int i=5; i<n-5; i++)
		ux[  i]=r10fdx*
	     (-2880.        *u[i-5]
	      +36000.       *u[i-4]
	      -216000.      *u[i-3]
	      +864000.      *u[i-2]
	      -3024000.     *u[i-1]
	      +0.           *u[i  ]
	      +3024000.     *u[i+1]
	      -864000.      *u[i+2]
	      +216000.      *u[i+3]
	      -36000.       *u[i+4]
	      +2880.        *u[i+5]);
	//Grid point n-4
	ux[n-5]=r10fdx*
	     (+2880.        *u[n-11]
	      -34560.       *u[n-10]
	      +194400.      *u[n-9]
	      -691200.      *u[n-8]
	      +1814400.     *u[n-7]
	      -4354560.     *u[n-6]
	      +1330560.     *u[n-5]
	      +2073600.     *u[n-4]
	      -388800.      *u[n-3]
	      +57600.       *u[n-2]
	      -4320.        *u[n-1]);
	//Grid point n-3
	ux[n-4]=r10fdx*
	     (-4320.        *u[n-11]
	      +50400.       *u[n-10]
	      -272160.      *u[n-9]
	      +907200.      *u[n-8]
	      -2116800.     *u[n-7]
	      +3810240.     *u[n-6]
	      -6350400.     *u[n-5]
	      +2756160.     *u[n-4]
	      +1360800.     *u[n-3]
	      -151200.      *u[n-2]
	      +10080.       *u[n-1]);
	// Grid point n-2
	ux[n-3]=r10fdx*
	     (+10080.       *u[n-11]
	      -115200.      *u[n-10]
	      +604800.      *u[n-9]
	      -1935360.     *u[n-8]
	      +4233600.     *u[n-7]
	      -6773760.     *u[n-6]
	      +8467200.     *u[n-5]
	      -9676800.     *u[n-4]
	      +4419360.     *u[n-3]
	      +806400.      *u[n-2]
	      -40320.       *u[n-1]);
	// Grid point n-1
	ux[n-2]=r10fdx*
	     (-40320.       *u[n-11]
	      +453600.      *u[n-10]
	      -2332800.     *u[n-9]
	      +7257600.     *u[n-8]
	      -15240960.    *u[n-7]
	      +22861440.    *u[n-6]
	      -25401600.    *u[n-5]
	      +21772800.    *u[n-4]
	      -16329600.    *u[n-3]
	      +6636960.     *u[n-2]
	      +362880.      *u[n-1]);
	// Grid point n
	ux[n-1]=r10fdx*
	     (+362880.      *u[n-11]
	      -4032000.     *u[n-10]
	      +20412000.    *u[n-9]
	      -62208000.    *u[n-8]
	      +127008000.   *u[n-7]
	      -182891520.   *u[n-6]
	      +190512000.   *u[n-5]
	      -145152000.   *u[n-4]
	      +81648000.    *u[n-3]
	      -36288000.    *u[n-2]
	      +10628640.    *u[n-1]);

	return ux;
}


array_type dss42(double xl, double xu, int n, array_type u, array_type ux, int nl, int nu) {
	//  Compute the spatial increment
	double dx=(xu-xl) /(n-1) ;
	double dx2 = dx*dx;
	array_type uxx(n);

//  uxx at the left boundary, without ux
   if (nl==1)
	   uxx[0]= (2.*u[0] - 5.*u[1] + 4.*u[2]- u[3])/(dx2);

//  uxx at the left boundary, including ux
   else if (nl==2)
     uxx[0]=   (-7.*u[0] + 8.*u[1] - u[2])/(2.*dx*dx) -6.*ux[ 0] /(2.*dx);

//  uxx at the right boundary, without ux
   if (nu==1)
     uxx[n-1]=(( 2.)*u[n-1] -5.*u[n-2] + 4.*u[n-3] - u[n-4])/(dx2);

//  uxx at the right boundary, including ux
   else if (nu==2)
     uxx[n-1]=(-7.*u[n-1] + 8.*u[n-2] - u[n-3])/(2.*dx*dx) + 6.*ux[n-1] /(2.*dx);


//  uxx at the interior grid points
   for (int i=1; i<n-1; i++)
     uxx[i]=(u[i-1]-2.*u[i]+u[i+1])/dx2;

	return uxx;
}

array_type dss44(double xl, double xu, int n, array_type u, array_type ux, int nl, int nu) {
	//  Compute the spatial increment
	double dx=(xu-xl) /(n-1) ;
	double dx2 = dx*dx;
	array_type uxx(n);

//  1/(12*dx**2) for subsequent use
    double r12dxs=1./(12.0*dx2);
//
//  uxx at the left boundary
//
    if (nl==1)
        uxx[0]=r12dxs*(45.0*u[0]-154.0*u[1]+214.0*u[2]-156.0*u[3]+61.0*u[4]-10.0*u[5]);
//

    else if (nl == 2)
        uxx[0]=r12dxs*(-415.0/6.0*u[0]+96.0*u[1]-36.0*u[2]+32.0/3.0*u[3]-3.0/2.0*u[4]-50.0*ux[0]*dx);

//
//  uxx at the right boundary
//

    if (nu == 1)
        uxx[n-1]=r12dxs*(45.0*u[n-1]-154.0*u[n-2]+214.0*u[n-3]-156.0*u[n-4]+61.0*u[n-5]-10.0*u[n-6]);
//

    else if (nu == 2)
         uxx[n-1]=r12dxs*((-415.0/6.0)*u[n-1]+96.0*u[n-2]-36.0*u[n-3]+(32.0/3.0)*u[n-4]-(3.0/2.0)*u[n-5]+50.0*ux[n-1]*dx);
//
//  uxx at the interior grid points
//
//     i = 2
    uxx[1]=r12dxs*(10.0*u[0]-15.0*u[1]-4.0*u[2]+14.0*u[3]-6.0*u[4]+1.0*u[5]);
//
//     i = n-1
    uxx[n-2]=r12dxs*(10.0*u[n-1]-15.0*u[n-2]-4.0*u[n-3]+14.0*u[n-4]-6.0*u[n-5]+1.0*u[n-6]);
//
//     i = 3, 4,, n-2
    for (int i=2; i<n-2; i++)
         uxx[i]=r12dxs*(-u[i-2]+16.0*u[i-1]-30.0*u[i ]+16.0*u[i+1]-u[i+2]);

    //for (auto i:u)
    //	std::cout<<i<<std::endl;

    //for (auto i:uxx)
    //	std::cout<<i<<std::endl;

  	return uxx;

}

array_type dss46(double xl, double xu, int n, array_type u, array_type ux, int nl, int nu) {
	//  Compute the spatial increment
	double dx=(xu-xl) /(n-1) ;
	double dx2 = dx*dx;
	array_type uxx(n);
	double rdxs=1.0/dx2;
   // Without ux
	if (nl == 1)
        uxx[0]=rdxs*
              (  5.211111111111110*u[0]
               -22.300000000000000*u[1]
               +43.950000000000000*u[2]
               -52.722222222222200*u[3]
               +41.000000000000000*u[4]
               -20.100000000000000*u[5]
                +5.661111111111110*u[6]
                -0.700000000000000*u[7]);
//
//     With ux
	else if (nl == 2)
        uxx[0]=rdxs*
              ( -7.493888888888860*u[0]
               +12.000000000000000*u[1]
                -7.499999999999940*u[2]
                +4.444444444444570*u[3]
                -1.874999999999960*u[4]
                +0.479999999999979*u[5]
                -0.055555555555568*u[6]
                -4.900000000000000*ux[0]*dx);
//
//  uxx at the right boundary
//
//     Without ux
    if (nu == 1)
        uxx[n-1]=rdxs*
              (  5.211111111111110*u[n-1]
               -22.300000000000000*u[n-2]
               +43.950000000000000*u[n-3]
               -52.722222222222200*u[n-4]
               +41.000000000000000*u[n-5]
               -20.100000000000000*u[n-6]
                +5.661111111111110*u[n-7]
                -0.700000000000000*u[n-8]);
//
//     With ux
    else if (nu == 2)
        uxx[n-1]=rdxs*
              ( -7.493888888888860*u[n-1]
               +12.000000000000000*u[n-2]
                -7.499999999999940*u[n-3]
                +4.444444444444570*u[n-4]
                -1.874999999999960*u[n-5]
                +0.479999999999979*u[n-6]
                -0.055555555555568*u[n-7]
                +4.900000000000000*ux[n-1]*dx);
//
//  uxx at the interior grid points

    uxx[1]=rdxs*
              (  0.700000000000000*u[0]
                -0.388888888888889*u[1]
                -2.700000000000000*u[2]
                +4.750000000000000*u[3]
                -3.722222222222220*u[4]
                +1.800000000000000*u[5]
                -0.500000000000000*u[6]
                +0.061111111111111*u[7]);

    uxx[2]=rdxs*
              ( -0.061111111111111*u[0]
                +1.188888888888890*u[1]
                -2.100000000000000*u[2]
                +0.722222222222223*u[3]
                +0.472222222222222*u[4]
                -0.300000000000000*u[5]
                +0.088888888888889*u[6]
                -0.011111111111111*u[7]);

    uxx[n-2]=rdxs*
              (  0.700000000000000*u[n-1]
                -0.388888888888889*u[n-2]
                -2.700000000000000*u[n-3]
                +4.750000000000000*u[n-4]
                -3.722222222222220*u[n-5]
                +1.800000000000000*u[n-6]
                -0.500000000000000*u[n-7]
                +0.061111111111111*u[n-8]);
//
    uxx[n-3]=rdxs*
              ( -0.061111111111111*u[n-1]
                +1.188888888888890*u[n-2]
                -2.100000000000000*u[n-3]
                +0.722222222222223*u[n-4]
                +0.472222222222222*u[n-5]
                -0.300000000000000*u[n-6]
                +0.088888888888889*u[n-7]
                -0.011111111111111*u[n-8]);
//

    for (int i=3; i<n-3; i++) {
    	uxx[i]=rdxs*
              (  0.011111111111111*u[i-3]
                -0.150000000000000*u[i-2]
                +1.500000000000000*u[i-1]
                -2.722222222222220*u[i  ]
                +1.500000000000000*u[i+1]
                -0.150000000000000*u[i+2]
                +0.011111111111111*u[i+3]);
    }

  	return uxx;

}

array_type dss48(double xl, double xu, int n, array_type u, array_type ux, int nl, int nu) {
	//  Compute the spatial increment
	double dx=(xu-xl) /(n-1) ;
	double dx2 = dx*dx;
	array_type uxx(n);
	double rdxs=1.0/dx2;
//
//  uxx at the left boundary
//
//     Without ux
      if (nl == 1)
      uxx[0]=rdxs*
             ( 6.463293650793652*u[0]
             -32.921428571428578*u[1]
             +83.842857142857156*u[2]
            -139.755555555555555*u[3]
            +162.474999999999999*u[4]
            -132.500000000000000*u[5]
             +74.544444444444444*u[6]
             -27.628571428571430*u[7]
              +6.083928571428572*u[8]
              -0.603968253968254*u[9]);
//
//     With ux
      else if (nl == 2)
      uxx[0]=rdxs*
            ( -8.914169501133784*u[0]
             +16.000000000000000*u[1]
             -14.000000000000000*u[2]
             +12.444444444444444*u[3]
              -8.750000000000000*u[4]
              +4.480000000000000*u[5]
              -1.555555555555555*u[6]
              +0.326530612244898*u[7]
              -0.031250000000000*u[8]
              -5.435714285714286*ux[0]*dx);

//
//  uxx at the right boundary
//
//     Without ux
      if (nu == 1)
      uxx[n-1]=rdxs*
            ( -0.603968253968254*u[n-10]
              +6.083928571428572*u[n-9]
             -27.628571428571430*u[n-8]
             +74.544444444444444*u[n-7]
            -132.500000000000000*u[n-6]
            +162.474999999999999*u[n-5]
            -139.755555555555555*u[n-4]
             +83.842857142857156*u[n-3]
             -32.921428571428578*u[n-2]
              +6.463293650793652*u[n-1]);
//
//     With ux
      else if (nu == 2)
      uxx[n-1]=rdxs*
             (-0.031250000000000*u[n-9]
              +0.326530612244905*u[n-8]
              -1.555555555555555*u[n-7]
              +4.480000000000000*u[n-6]
              -8.750000000000000*u[n-5]
             +12.444444444444444*u[n-4]
             -14.000000000000000*u[n-3]
             +16.000000000000000*u[n-2]
              -8.914169501133790*u[n-1]
              +5.435714285714287*ux[n-1  ]*dx);

//
//  uxx at the interior grid points
//
      uxx[1]=rdxs*
              (0.603968253968254*u[0]
              +0.423611111111111*u[1]
              -5.742857142857143*u[2]
             +11.366666666666665*u[3]
             -12.922222222222221*u[4]
             +10.274999999999999*u[5]
              -5.666666666666665*u[6]
              +2.068253968253968*u[7]
              -0.450000000000000*u[8]
              +0.044246031746032*u[9]);
//
      uxx[2]=rdxs*
             (-0.044246031746032*u[0]
              +1.046428571428571*u[1]
              -1.567460317460318*u[2]
              -0.433333333333333*u[3]
              +2.075000000000000*u[4]
              -1.772222222222222*u[5]
              +0.983333333333333*u[6]
              -0.357142857142857*u[7]
              +0.077182539682540*u[8]
              -0.007539682539683*u[9]);
//
      uxx[3]=rdxs*
              (0.007539682539683*u[0]
              -0.119642857142857*u[1]
              +1.385714285714286*u[2]
              -2.472222222222222*u[3]
              +1.150000000000000*u[4]
              +0.175000000000000*u[5]
              -0.188888888888889*u[6]
              +0.078571428571429*u[7]
              -0.017857142857143*u[8]
              +0.001785714285714*u[9]);
//
      uxx[n-4]=rdxs*
              (0.001785714285714*u[n-10]
              -0.017857142857143*u[n-9]
              +0.078571428571429*u[n-8]
              -0.188888888888889*u[n-7]
              +0.175000000000000*u[n-6]
              +1.150000000000000*u[n-5]
              -2.472222222222224*u[n-4]
              +1.385714285714286*u[n-3]
              -0.119642857142857*u[n-2]
              +0.007539682539683*u[n-1]);
//
      uxx[n-3]=rdxs*
             (-0.007539682539683*u[n-10]
              +0.077182539682540*u[n-9]
              -0.357142857142857*u[n-8]
              +0.983333333333333*u[n-7]
              -1.772222222222222*u[n-6]
              +2.075000000000001*u[n-5]
              -0.433333333333335*u[n-4]
              -1.567460317460318*u[n-3]
              +1.046428571428572*u[n-2]
              -0.044246031746032*u[n-1]);
//
      uxx[n-2]=rdxs*
              (0.044246031746032*u[n-10]
              -0.450000000000000*u[n-9]
              +2.068253968253968*u[n-8]
              -5.666666666666667*u[n-7]
             +10.275000000000000*u[n-6]
             -12.922222222222222*u[n-5]
             +11.366666666666667*u[n-4]
              -5.742857142857142*u[n-3]
              +0.423611111111112*u[n-2]
              +0.603968253968254*u[n-1]);
//

      for (int i=4; i<n-4; i++)
      uxx[i]=rdxs*
             (-0.001785714285714*u[i-4]
              +0.025396825396825*u[i-3]
              -0.200000000000000*u[i-2]
              +1.600000000000000*u[i-1]
              -2.847222222222221*u[i  ]
              +1.600000000000000*u[i+1]
              -0.200000000000000*u[i+2]
              +0.025396825396825*u[i+3]
              -0.001785714285714*u[i+4]);

      return uxx;
}

array_type dss50(double xl, double xu, int n, array_type u, array_type ux, int nl, int nu) {
	//  Compute the spatial increment
	double dx=(xu-xl) /(n-1) ;
	double dx2 = dx*dx;
	array_type uxx(n);
	double rdxs=1.0/dx2;
//
//  uxx at the left boundary
//
//     Without ux
	if (nl== 1)
         uxx[0]=rdxs*
               (  7.561626984126982*u[0]
                -44.437301587301590*u[1]
               +138.593253968253980*u[2]
               -295.519841269841320*u[3]
               +457.029761904761930*u[4]
               -521.113333333333460*u[5]
               +439.394444444444330*u[6]
               -271.261904761904700*u[7]
               +119.413690476190470*u[8]
                -35.551587301587304*u[9]
                 +6.423730158730158*u[10]
                 -0.532539682539683*u[11]);
//
//     With ux
	else if (nl == 2)
         uxx[0]=rdxs*
               (-10.128622763920379*u[0]
                +20.000000000000000*u[1]
                -22.499999999999972*u[2]
                +26.666666666666572*u[3]
                -26.249999999999943*u[4]
                +20.159999999999968*u[5]
                -11.666666666666686*u[6]
                 +4.897959183673493*u[7]
                 -1.406250000000000*u[8]
                 +0.246913580246911*u[9]
                 -0.020000000000001*u[10]
                 -5.857936507936508*ux[0]*dx);

//
//  uxx at the right boundary
//
//     Without ux
	if (nu == 1)
         uxx[n-1]=rdxs*
               ( -0.532539682539683*u[n-12]
                 +6.423730158730161*u[n-11]
                -35.551587301587304*u[n-10]
               +119.413690476190480*u[n-9]
               -271.261904761904760*u[n-8]
               +439.394444444444390*u[n-7]
               -521.113333333333340*u[n-6]
               +457.029761904761930*u[n-5]
               -295.519841269841270*u[n-4]
               +138.593253968253980*u[n-3]
                -44.437301587301590*u[n-2]
                 +7.561626984126984*u[n-1]);
//
//     With ux
	else if (nu == 2)
         uxx[n-1]=rdxs*
               ( -0.019999999999999*u[n-11]
                 +0.246913580246904*u[n-10]
                 -1.406249999999986*u[n-9]
                 +4.897959183673493*u[n-8]
                -11.666666666666686*u[n-7]
                +20.159999999999968*u[n-6]
                -26.249999999999943*u[n-5]
                +26.666666666666629*u[n-4]
                -22.499999999999972*u[n-3]
                +20.000000000000000*u[n-2]
                -10.128622763920383*u[n-1]
                 +5.857936507936508*ux[n-1 ]*dx);

//
//  uxx at the interior grid points
//
	uxx[1]=rdxs*
	   (  0.532539682539683*u[0]
			 +1.171150793650794*u[1]
			 -9.289682539682540*u[2]
			+21.434523809523807*u[3]
			-31.912698412698408*u[4]
			+35.258333333333333*u[5]
			-29.046666666666663*u[6]
			+17.623015873015873*u[7]
			 -7.654761904761902*u[8]
			 +2.254960317460317*u[9]
			 -0.403968253968254*u[10]
			 +0.033253968253968*u[11]);
//
	uxx[2]=rdxs*
	   ( -0.033253968253968*u[0]
			 +0.931587301587302*u[1]
			 -1.023611111111112*u[2]
			 -1.973809523809523*u[3]
			 +4.973809523809524*u[4]
			 -5.575555555555556*u[5]
			 +4.531666666666666*u[6]
			 -2.709523809523809*u[7]
			 +1.162301587301588*u[8]
			 -0.338888888888889*u[9]
			 +0.060198412698413*u[10]
			 -0.004920634920635*u[11]);
//
//
	uxx[3]=rdxs*
	   (  0.004920634920635*u[0]
			 -0.092301587301587*u[1]
			 +1.256349206349206*u[2]
			 -2.106150793650793*u[3]
			 +0.461904761904762*u[4]
			 +1.076666666666667*u[5]
			 -1.028888888888889*u[6]
			 +0.634523809523810*u[7]
			 -0.273809523809524*u[8]
			 +0.079761904761905*u[9]
			 -0.014126984126984*u[10]
			 +0.001150793650794*u[11]);
//
	uxx[4]=rdxs*
	   ( -0.001150793650794*u[0]
			 +0.018730158730159*u[1]
			 -0.168253968253968*u[2]
			 +1.509523809523809*u[3]
			 -2.675793650793650*u[4]
			 +1.373333333333333*u[5]
			 +0.013333333333334*u[6]
			 -0.117460317460318*u[7]
			 +0.064880952380952*u[8]
			 -0.020634920634921*u[9]
			 +0.003809523809524*u[10]
			 -0.000317460317460*u[11]);
//
	uxx[n-5]=rdxs*
		(-0.000317460317460*u[n-12]
			 +0.003809523809524*u[n-11]
			 -0.020634920634921*u[n-10]
			 +0.064880952380952*u[n-9]
			 -0.117460317460317*u[n-8]
			 +0.013333333333333*u[n-7]
			 +1.373333333333333*u[n-6]
			 -2.675793650793652*u[n-5]
			 +1.509523809523810*u[n-4]
			 -0.168253968253968*u[n-3]
			 +0.018730158730159*u[n-2]
			 -0.001150793650794*u[n-1]);
//
	uxx[n-4]=rdxs*
		( 0.001150793650794*u[n-12]
			 -0.014126984126984*u[n-11]
			 +0.079761904761905*u[n-10]
			 -0.273809523809524*u[n-9]
			 +0.634523809523809*u[n-8]
			 -1.028888888888889*u[n-7]
			 +1.076666666666667*u[n-6]
			 +0.461904761904762*u[n-5]
			 -2.106150793650793*u[n-4]
			 +1.256349206349206*u[n-3]
			 -0.092301587301587*u[n-2]
			 +0.004920634920635*u[n-1]);
//
	uxx[n-3]=rdxs*
		(-0.004920634920635*u[n-12]
			 +0.060198412698413*u[n-11]
			 -0.338888888888889*u[n-10]
			 +1.162301587301588*u[n-9]
			 -2.709523809523809*u[n-8]
			 +4.531666666666666*u[n-7]
			 -5.575555555555556*u[n-6]
			 +4.973809523809526*u[n-5]
			 -1.973809523809526*u[n-4]
			 -1.023611111111110*u[n-3]
			 +0.931587301587302*u[n-2]
			 -0.033253968253968*u[n-1]);
//
	uxx[n-2]=rdxs*
		( 0.033253968253968*u[n-12]
			 -0.403968253968254*u[n-11]
			 +2.254960317460318*u[n-10]
			 -7.654761904761904*u[n-9]
			+17.623015873015873*u[n-8]
			-29.046666666666670*u[n-7]
			+35.258333333333340*u[n-6]
			-31.912698412698411*u[n-5]
			+21.434523809523810*u[n-4]
			 -9.289682539682541*u[n-3]
			 +1.171150793650794*u[n-2]
			 +0.532539682539683*u[n-1]);
//
	for (int i=5; i<n-5; i++)
		uxx[i]=rdxs*
			( 0.000317460317460*u[i-5]
			 -0.004960317460317*u[i-4]
			 +0.039682539682540*u[i-3]
			 -0.238095238095238*u[i-2]
			 +1.666666666666667*u[i-1]
			 -2.927222222222222*u[i  ]
			 +1.666666666666667*u[i+1]
			 -0.238095238095238*u[i+2]
			 +0.039682539682540*u[i+3]
			 -0.004960317460317*u[i+4]
			 +0.000317460317460*u[i+5]);

	return uxx;
}

void mol ( const array_type &u , array_type &ut , const double /* t */ )
{
	int n = 21;
    double dx2=(1.0/(n-1))*(1.0/(n-1));

	// PDE
    for (int i=0; i<n; i++) {
		if (i == 0)
			ut[i]=0.0;
		else if (i == n-1)
			ut[i]=2.0*(u[i-1]-u[i])/dx2;
		else
			ut[i]=(u[i+1]-2.0*u[i]+u[i-1])/dx2;
    }

}

void mol_green ( const array_type &u , array_type &ut , const double /* t */ )
{
	int n = 101;
	double xl=-10.0;
	double xu= 10.0;
	double dx=(xu-xl)/(n-1);
    double dx2=dx*dx;

	// PDE
    for (int i=0; i<n; i++) {
		if (i == 0)
			ut[i]=0.0;
		else if (i == n-1)
			ut[i]=0.0;
		else
			ut[i]=(u[i+1]-2.0*u[i]+u[i-1])/dx2;
    }

}

array_type dss007(double xl, double xu, int n, array_type u)
{
	//Compute the spatial increment
	double dx=(xu-xl)/(n-1);
	double r8dx3=1.0/(8.0*dx*dx*dx);
	array_type uxxx(n);


	for (int i=0; i<n; i++) {
		// At the left end, uxxx = 0
		if (i<3) uxxx[i] = 0.0;
		// At the right end, uxxx = 0
		else if (i > (n-4)) uxxx[i] = 0.0;
		else
		    uxxx[i]=r8dx3*
		       (u[i-3] - 8.0*u[i-2] + 13.0*u[i-1] - 13.0*u[i+1] + 8.0*u[i+2] - u[i+3]);
	}
	return uxxx;
}

#endif /* DSSCPP_H_ */
